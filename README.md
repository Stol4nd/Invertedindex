## Тема: реализация приложения поиска в CSV-файлах

Реализуем текстовый поиск по CSV-файлам 

## Общие моменты

### Самостоятельное изучение библиотек

На свете существует масса библиотек для Python - как встроенных, так и сторонних.

Изучать их все на лекциях и семинарах невозможно.

Но в реальной жизни реальные приложения должны на них опираться.

Поэтому на занятиях мы изучаем те из них, которые основываются на каких-то неочевидных идеях,
а все остальное остается на самостоятельное изучение.


### Версия Python

Работы проверяются в Python 3.14.

Если у вас другая версия, убедитесь, что в 3.14 ваше решение тоже работает.

### Изобретение велосипедов

Иногда задания намеренно нацелены на изобретение велосипеда. Вряд ли мы мимоходом создадим систему полнотекстового поиска в файлах
лучше уже существующих, но мы это делаем, чтобы научиться создавать приложения.

И здесь мы намеренно не  используем готовые поисковые библиотеки.

С другой стороны -  наша задача разбивается на подзадачи.

И если в ходе такого разбиения нужно выполнить подзадачу, далекую от исходной
задачи, то тут изобретать свои велолипеды вместо чего-то готового стандартно-библиотечного не стоит.

Если в домашке про текстовый поиск надо удалить каталог с подкаталогами - не надо руками выписывать рекурсию. Лучше
найти подходящую функцию в стандартной библиотеке.


### Инкрементальные задания

Некоторые задания являются шагом к реализации последующих. Если вы делаете следующие задания,
то не обязательно фиксировать где-то неполные версии из текущих заданий - если только явным образом не сказано так
сделать.

### Ключевые оцениваемые факторы

- корректность работы

- декомпозиция (DRY, разделение ответственности) - на моменти выдачи мы уже давно прошли функции, через три дня пройдем модули,
а за 5 дней до дедлайна и про классы успеем подробно поговорить

- правильная работа с файлами (своевременное закрытие, оптимизация объема чтения/записи, риски упасть по памяти по мере роста
объема данных) 

# Требования к коду

Проходят проверки

```
python3 -m  pycodestyle --max-line-length=120 *.py
```

```
python3 -m ruff  check --config ruff.toml
```



## Задание 1

15 баллов

Создадим каркас приложения. Назовем его `searcher.py`

Создадим функцию `main`, вход в нее.

Реализуем обработку параметров командной строки. 

Наше приложение должно выполнять несколько видов действий, для каждого из которых
может потребоваться свой набор аргументов командной строки.

Примером такого рода приложения является `git`. При его запуске из командной строки
указывается сначала подкоманда, а потом - ее параметры (`git checkout -b my-branch`).

Поэтому такого типа приложения часто называют `git style`.

В этом задании надо заложить основы такого приложения.

Пусть оно принимает следующие команды: `init`, `info`, `add` и `find`.

Остальные должны восприниматься как ошибочные. 

Для каждой подкоманды надо поддержать параметр `--root <имя корневого каталога>`.

Если параметр `--root` не задан, это должно восприниматься как ошибка.

Если параметр `--root` задан до команды:

```
python3 searcher.py --root ./root-dir init
```

это должно восприниматься как корректная командная строка.

Если параметр `--root` задан после команды:

```
python3 searcher.py init --root ./root-dir
```

это должно восприниматься тоже как корректная командная строка
(с той же семантикой, как и в варианте "до команды".

Если параметр `--root` задан до и после команды:

```
python3 searcher.py --root ./root-dir init --root ./root-dir 
```

это должно восприниматься как некорректная командная строка.

Также надо поддержать для каждой подкоманды свой набор параметров.

Для `init`: `--drop-existing` (`python searcher.py init --drop-existing`)

Для `info`: ничего специфичного

Для `add`: `<имя файла>` (обязательная, т.е. `python searcher.py add f.txt` - 
можно и нужно, а `python searcher.py add` - нельзя)

Для `find`: `<слово 1> ... <слово n> --limit 10` (слов может быть несколько но обязано быть хотя бы одно,
а `--limit` не обязателен)

Такие командно специфичные параметры могут задаваться только после команды.

Например:

```
python3 searcher.py --drop-existing  init --root ./root-dir
```

должна обрабатываться как ошибка.

На этом этапе достаточно:

- обработать как ошибку непредусмотренные параметры
- обработать как ошибку на отсутствующие обязательные параметры
- обработать как ошибку нечисловое значение в параметре `--limit`

В случае корректных параметров пока ничего существенного делать не надо. Достаточно напечатать
полученную подкоманду и переданные параметры в обработанном виде.

Например, при вызове `python3 searcher.py find abc hello --limit 5` напечатайте

```
command: find
word 1: abc
word 2: hello
limit: 5
```

А при вызове `python3 searcher.py find abc hello` напечатайте

```
command: find
word 1: abc
word 2: hello
limit: 100 (by default)
```

Старайтесь максимально задействовать возможности `argparse`.

В частности, "обработать как ошибку" означает, что лучше всего сделать так, чтобы `argparse`
вывел типовое сообщение об ошибке.

Особенно может помочь вот эта глава: https://docs.python.org/3/library/argparse.html#sub-commands 


## Задание 2 

20 баллов

Реализуем подкоманду `init`.

Как следует из названия, она должна проинициализировать нашу поисковую систему.

Мы хотим отвести каталог на диске под служебную информацию, которая поможет нам выполнять поиск.

Путь к этому каталогу мы и передаем в параметре `--root`.

Нужно предусмотреть следующие варианты:

- по этому пути уже есть каталог или файл

- там ничего нет, но и нам создать ничего не удается

Если нам создать ничего не удается - надо это понять и сообщить о проблеме.

Если по указанному пути живет файл - надо это понять и сообщить о проблеме.

Если по указанному пути живет каталог - надо это понять, а дальше есть два варианта.

Если это просто какой-то каталог - не будем ничего создавать и сообщим о проблеме.

А если это корневой каталог нашей поисковой системы (ранее нами созданный) - обратимся к опции 
`--drop-existing`.

Если ее нет - не будем ничего создавать и сообщим о проблеме.

А если есть - тогда удалим.

А как мы поймем - "наш" это каталог или чей-то ?

Давайте определять по наличию файла `.searcher` и наличию в нем текста `IT'S SEARCHER`.
Ровно такого.

И если мы по этому маркеру решили, что это наш каталог и есть опция `--drop-existin`, то уничтожим старые данные.

Если каталога не было, то мы его создаем и заполняем:

- создаем файл-маркер `.searcher`
- создаем каталог `index`
- создаем каталог `files`

Содержимое файла `.searcher` мы знаем.

Каталог `index` оставим пустым. В каталоге `files` создадим файл `.splits` с содержимым

```
0 0
```

Также создадим в каталоге `files` пустой файл `0_files`.

Если каталог был, не пересоздаем то, что уже есть и пригодится дальше (подкаталоги, например), но приводим его в начальное состояние:

- файл-маркер `.search` оставляем как есть
- если каталог `index` существует и пуст, оставляем как есть
- если каталог `index` существует и не пуст - удаляем (возможные подкаталоги - тоже, и их подкаталоги и так далее рекурсивно)
- если каталог `index` не существует - создаем
- аналогично с каталогом `files`

Каталог `index` оставим пустым. В каталоге `files` создадим файл `.splits` с уже известным содержимым. Если он там был - перетрем. 
Аналогично с файлом `0_files`.


# Задание 3

20 баллов

Начнем реализовывать подкоманду `add`.

Она должна добавить файл в нашу систему.

Мы исходим из того, что файлы не меняются. Поэтому снимается проблема реагирования на изменения.

И удалять файлы из нашей системы мы тоже не собираемся.

Будем только добавлять. Но следить за тем, чтобы файл не добавлялся дважды.

Сначала нам надо проверить, что файл существует. Эту проверку не надо встраивать в `argparse`.
Эту уже такая глубоко семантическая проверка.

Надо понимать, что файл в командной строке может задаваться и относительным путем, и абсолютным.
Если он задан в относительном пути - надо получить абсолютный (исходя из текущего каталога).

После получения абсолютного пути надо его привести в каноническую форму. Например, путь `/a/b/c/../d`
является абсолютным, но не каноническим. Его каноническим эквивалентом является `/a/b/d`.

(Помним про велосипеды и про то, это далековато от текстового поиска, то есть это очень подходит
для использования стандартного кода).

Получив канонический абсолютный путь к файлу, надо поискать его в `files/0_files`.
Как именно - станет понятно чуть ниже, после описания добавления.

Если файл нашли - сообщаем о том, что он уже добавлен.

Если не добавлен - нам нужно назначить файлу идентификатор.

Идентификатор получим следующим образом: прочитаем все строчки файлв `files/.splits`, суммируем все вторые колонки и прибавим к сумме `1`.

Получив идентификатор, надо добавить в `files/0_files` строку вида

```
2135 /a/b/d
```

После чего надо обновить файл `files/.splits`.

В общем случае мы хотели бы работать с несколькими файлами `0_files`, `1_files` и т.д. и для каждого файла держать в файле
`files/.splits` строчку, отражающую число строк в соответствующем файле.

Полностью эту часть мы развернем в следующей домашке. А пока хотелось бы реализовать функцию, которая бы умела обновлять в файле строчку
с произвольным номером.

Функция должна принимать имя файла и номер строки. Она должна создать временный файл и перекинуть в него содержимое исходного. Строки с номером,
не равным заданному, перекидываются без изменений, а указанная - с увеличением второй колонки на 1.

После успешного переноса данных в новый файл оба файла надо закрыть и временный файл переименовать в `files/.splits`.

И дальше эту функцию нужно вызвать с параметром 0.

Таким образом мы зарегистрировали файл.

Но его содержимое пока остается для нашего индекса неизвестным.



# Задание 4 

25 баллов

Теперь надо добавить содержимое.

Содержимое будем хранить в каталоге `index`. Там будут жить файлы с именами `00`, `01`, `02` и так далее.
`00` соответствует букве `a`, `01` - `b`, `25` - `z`, `26` - `а`, `27` - `б`.

Файлы должны создаваться по мере появления слов, начинающихся с соответствующей буквы. 

Будем считать, что в файлах хранится содержимое в виде очень простых csv-файлов.

Колонки в них разделены табуляцией, и в колонках может находиться текст или число. А также колонка
может быть пустой. Под пустой понимаем строку, состоящую из пробельных символов.

Если первый непустой символ - цифра, то это числовая колонка.

Если первый непустой символ - алфавитный символ, то считаем, что в колонке текст.

Иначе - колонка пустая.

Если в колонке текст, то будем полагаться на то, что текст крайне простой. Слова, разделенные пробельными
последовательностями. Даже без перевода строки.

Строгой табличности может не быть (в разных строках может быть разное число ячеек) и строгой поколоночной типизации -
тоже.

Пример возможного содержимого

```
abc def\t  123\t\thello
1111\t qwerty
```

В нулевой строке нулевая и третья колонки текстовые, первая - числовая, а вторая - пустая.

В первой строке нулевая колонка числовая, а первая - текстовая.

Про каждое слово будем хранить данные о его вхождениях.

Данные о вхождениях - это:

- номера файлов (полученные при регистрации файлов), в которых слово встречалось

- байтовые смещения тех строк файла, в которых слово было найдено

- номера колонок, в которых слово найдено


Например, в таком файле:

```
hello\tworld
123\tabc\tdef
```

байтовыми смещениями строк будут 0 и 12 (если перевод строки - в Unix-стиле) или 13
(если перевод строки в Windows-стиле), о номерами колонки будут `0` для `hello`,
`1` для `world`, `1` для `abc`, `2` для `def`.

Если файл был с идентификатором `5`, а слово `world` еще ни разу не встречалось,
то для него должна появиться такая строка:

```
world: 5[0:1]
```

Если бы первая строка выглядела так:

```
hello\tworld\tworld
```

то строка должна была бы стать такой:

```
world: 5[0:1,2]
```

То есть для в квадратных скобках после идентификатора файла идет байтовое смещение строки, двоеточие
и разделенные запятой номера полей, где оно найдено.

Если слово встретилось в колонке несколько раз, то колонка появляется в списке все равно один раз.

Если в файле слово встречается несколько раз в разных строках, то для каждой строки добавляется своя пара
квадратных скобок. 

Например,

```
hello\tworld\tworld
123\tabc world
```

приведет к 

```
world: 5[0:1,2][18:1]
```

Если слово встречается в разных файлах, то элементы, описывающие вхождения в каждый отдельный файл,
отделяются пробелами.

Например:

```
world: 5[0:1,2][18:1] 8[123:2][167:0]
```

Если слово не встречалось, его в файле нет.

При первом появлении слово надо добавить в файл.

Изменение файла делаем через создание нового с последующим переименованием.

Если в тексте несколько слов на одну букву - надо обновить файл за один раз.

При появлении новых слов должен сохраняться алфавитный порядок слов в файле.


# Задание 5

20 баллов

А давайте поддержим передачу в `add` нескольких файлов

Нет, это не про то, чтобы написать цикл и получить 20 баллов.

Надо собрать всю информацию о добавляемых словах в памяти, а потом единожды все обновить.

То есть сколько бы файлов мы ни указали, каждый "буквенный" файл мы должны обновить только 1 раз.

И зарегистрировать файлы тоже хотелось бы оптимальным образом.

